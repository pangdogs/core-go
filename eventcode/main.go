package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	goPackage := flag.String("package", "", "go package")
	declFile := flag.String("decl", "", "event declare go file (*.go)")
	genFile := flag.String("gen", "", "event generate go file (*.go)")
	corePackage := flag.String("core", "core", "core package")
	eventPrefix := flag.String("prefix", "Event", "event prefix")

	flag.Parse()

	if *declFile == "" || filepath.Ext(*declFile) != ".go" {
		flag.Usage()
		panic(flag.ErrHelp)
	}

	if *goPackage == "" {
		flag.Usage()
		panic(flag.ErrHelp)
	}

	if *genFile == "" {
		*genFile = strings.TrimSuffix(*declFile, ".go") + "_gencode.go"
	} else if filepath.Ext(*genFile) != ".go" {
		flag.Usage()
		panic(flag.ErrHelp)
	}

	if *corePackage != "" {
		*corePackage = *corePackage + "."
	}

	declFileData, err := ioutil.ReadFile(*declFile)
	if err != nil {
		panic(err)
	}

	fset := token.NewFileSet()

	fast, err := parser.ParseFile(fset, *declFile, declFileData, 0)
	if err != nil {
		panic(err)
	}

	genCode := &bytes.Buffer{}

	fmt.Fprintf(genCode, `// Code generated by %s%s; DO NOT EDIT.
package %s
`, strings.TrimSuffix(filepath.Base(os.Args[0]), filepath.Ext(os.Args[0])),
		func() (args string) {
			for _, arg := range os.Args[1:] {
				args += " " + arg
			}
			return
		}(),
		*goPackage)

	ast.Inspect(fast, func(node ast.Node) bool {
		ts, ok := node.(*ast.TypeSpec)
		if !ok {
			return true
		}

		if !ts.Name.IsExported() {
			return true
		}

		eventName := ts.Name.Name

		if !strings.HasPrefix(eventName, *eventPrefix) {
			return true
		}

		eventIFace, ok := ts.Type.(*ast.InterfaceType)
		if !ok {
			return true
		}

		if eventIFace.Methods.NumFields() <= 0 {
			return true
		}

		eventFuncField := eventIFace.Methods.List[0]

		if len(eventFuncField.Names) <= 0 {
			return true
		}

		eventFuncName := eventFuncField.Names[0].Name

		eventFunc, ok := eventFuncField.Type.(*ast.FuncType)
		if !ok {
			return true
		}

		eventFuncParamsDecl := ""
		eventFuncParams := ""

		if eventFunc.Params != nil {
			for i, param := range eventFunc.Params.List {
				paramName := ""

				for _, pn := range param.Names {
					if paramName != "" {
						paramName += ", "
					}
					paramName += pn.Name
				}

				if paramName == "" {
					paramName = fmt.Sprintf("p%d", i)
				}

				if eventFuncParams != "" {
					eventFuncParams += ", "
				}
				eventFuncParams += paramName

				begin := fset.Position(param.Type.Pos())
				end := fset.Position(param.Type.End())

				eventFuncParamsDecl += fmt.Sprintf(", %s %s", paramName, declFileData[begin.Offset:end.Offset])
			}
		}

		eventFuncTypeParamsDecl := ""
		eventFuncTypeParams := ""

		if ts.TypeParams != nil {
			for i, typeParam := range ts.TypeParams.List {
				typeParamName := ""

				for _, pn := range typeParam.Names {
					if typeParamName != "" {
						typeParamName += ", "
					}
					typeParamName += pn.Name
				}

				if typeParamName == "" {
					typeParamName = fmt.Sprintf("p%d", i)
				}

				if eventFuncTypeParams != "" {
					eventFuncTypeParams += ", "
				}
				eventFuncTypeParams += typeParamName

				begin := fset.Position(typeParam.Type.Pos())
				end := fset.Position(typeParam.Type.End())

				if eventFuncTypeParamsDecl != "" {
					eventFuncTypeParamsDecl += ", "
				}
				eventFuncTypeParamsDecl += fmt.Sprintf("%s %s", typeParamName, declFileData[begin.Offset:end.Offset])
			}
		}

		if eventFuncTypeParamsDecl != "" {
			eventFuncTypeParamsDecl = fmt.Sprintf("[%s]", eventFuncTypeParamsDecl)
		}

		if eventFuncTypeParams != "" {
			eventFuncTypeParams = fmt.Sprintf("[%s]", eventFuncTypeParams)
		}

		if eventFunc.Results.NumFields() > 0 {
			eventRet, ok := eventFunc.Results.List[0].Type.(*ast.Ident)
			if !ok {
				return true
			}

			if eventRet.Name != "bool" {
				return true
			}

			fmt.Fprintf(genCode, `
func Emit%[1]s%[6]s(event %[5]sIEvent%[3]s) {
	if event == nil {
		panic("nil event")
	}
	event.Emit(func(delegate %[5]sFastIFace) bool {
		return %[5]sFast2IFace[%[1]s%[7]s](delegate).%[2]s(%[4]s)
	})
}
`, eventName, eventFuncName, eventFuncParamsDecl, eventFuncParams, *corePackage, eventFuncTypeParamsDecl, eventFuncTypeParams)

		} else {

			fmt.Fprintf(genCode, `
func Emit%[1]s%[6]s(event %[5]sIEvent%[3]s) {
	if event == nil {
		panic("nil event")
	}
	event.Emit(func(delegate %[5]sFastIFace) bool {
		%[5]sFast2IFace[%[1]s%[7]s](delegate).%[2]s(%[4]s)
		return true
	})
}
`, eventName, eventFuncName, eventFuncParamsDecl, eventFuncParams, *corePackage, eventFuncTypeParamsDecl, eventFuncTypeParams)
		}

		fmt.Println(eventName)

		return true
	})

	if err := ioutil.WriteFile(*genFile, genCode.Bytes(), os.ModePerm); err != nil {
		panic(err)
	}
}
